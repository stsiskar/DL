<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convolutional Layer Visualization</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --text-main: #f1f5f9;
            --text-muted: #94a3b8;
            --accent: #38bdf8;
            --accent-hover: #0ea5e9;
            --highlight-input: #f43f5e;   /* red/pink */
            --highlight-weight: #fbbf24;  /* amber */
            --highlight-calc: #a3e635;    /* green */
            --border-color: #334155;
            --cell-size: 32px;
            --gap: 3px;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: auto; /* allow horizontal scrolling if needed */
        }

        header {
            background-color: var(--card-bg);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 { margin: 0; font-size: 1.25rem; font-weight: 600; color: var(--accent); }
        p.subtitle { margin: 0; font-size: 0.85rem; color: var(--text-muted); }

        main {
            display: flex;
            flex: 1;
            padding: 2rem;
            gap: 2rem;
            overflow-x: auto;  /* horizontal scrollbar for whole content */
        }

        .sidebar {
            flex: 0 0 280px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .controls-card {
            background-color: var(--card-bg);
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .control-group { margin-bottom: 1.25rem; }
        .control-group:last-child { margin-bottom: 0; }

        .control-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        .value-display { color: var(--accent); font-weight: bold; font-family: monospace; }

        .range-wrapper,
        .input-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-adjust {
            background: var(--border-color);
            border: none;
            color: var(--text-main);
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .btn-adjust:hover { background: var(--accent); color: #fff; }
        .btn-adjust:active { transform: scale(0.95); }

        input[type="range"] {
            flex: 1;
            cursor: pointer;
            accent-color: var(--accent);
        }

        input[type="number"] {
            width: 60px;
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: #020617;
            color: var(--text-main);
            font-family: monospace;
        }

        select {
            width: 100%;
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: #020617;
            color: var(--text-main);
            font-size: 0.9rem;
        }

        .viz-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2.5rem;
            align-items: center;
        }

        .stage-row {
            display: flex;
            flex-wrap: nowrap;   /* keep panels on one line */
            gap: 2rem;
            justify-content: flex-start;
            align-items: flex-start;
            width: max-content;  /* row can be wider than viewport */
        }

        .panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(30, 41, 59, 0.5);
            padding: 1rem;
            border-radius: 12px;
            border: 1px solid transparent;
            transition: border-color 0.3s;
        }

        .panel:hover { border-color: var(--border-color); }

        .panel-title {
            margin-bottom: 0.5rem;
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-main);
            text-align: center;
        }

        .panel-subtitle {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
            font-family: monospace;
            text-align: center;
        }

        .grid-wrapper {
            display: grid;
            gap: var(--gap);
            padding: 8px;
            background: var(--card-bg);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: #475569;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.7rem;
            color: rgba(255,255,255,0.95);
            cursor: default;
            user-select: none;
            font-family: monospace;
        }

        /* Padding visualization: white 0 only for padding cells */
        .cell.padding {
            background-color: #ffffff;
            border: 1px solid var(--border-color);
            color: #000000;
        }

        /* Hover highlight states */
        .cell.active-input {
            background-color: var(--highlight-input) !important;
            color: #fff;
            box-shadow: 0 0 8px var(--highlight-input);
            z-index: 1;
        }

        .cell.active-weight {
            background-color: var(--highlight-weight) !important;
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 8px var(--highlight-weight);
            z-index: 1;
        }

        .cell.active-result {
            background-color: var(--highlight-calc) !important;
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 8px var(--highlight-calc);
            z-index: 1;
        }

        .symbol {
            align-self: center;
            font-size: 2rem;
            color: var(--text-muted);
            font-weight: bold;
        }

        .status-box {
            width: 100%;
            max-width: 900px;
            background: rgba(15, 23, 42, 0.9);
            border-radius: 10px;
            border: 1px solid var(--border-color);
            padding: 0.75rem 1rem;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .status-highlight {
            color: var(--accent);
            font-family: monospace;
        }

        @media (max-width: 1100px) {
            main { flex-direction: column; }
            .sidebar { width: 100%; flex: none; }
            .controls-card { max-width: 100%; }
        }
    </style>
</head>
<body>

<header>
    <div>
        <h1>Convolutional Layer</h1>
        <p class="subtitle">Interactive visualization of Input â†’ Filter â†’ Output</p>
    </div>
</header>

<main>
    <!-- Sidebar Controls -->
    <aside class="sidebar">
        <div class="controls-card">

            <!-- Image Pattern -->
            <div class="control-group">
                <div class="control-header">
                    <label>Image Pattern</label>
                </div>
                <select id="img-type">
                    <option value="simple">ðŸ™‚ Simple Smile</option>
                </select>
            </div>

            <!-- Input Size W -->
            <div class="control-group">
                <div class="control-header">
                    <label>Input Size (W)</label>
                    <span id="val-W" class="value-display">28</span>
                </div>
                <div class="range-wrapper">
                    <button class="btn-adjust" onclick="adjustRange('W', -1)">-</button>
                    <input type="range" id="inp-W" min="2" max="28" value="28">
                    <button class="btn-adjust" onclick="adjustRange('W', 1)">+</button>
                </div>
            </div>

            <!-- Filter Size F -->
            <div class="control-group">
                <div class="control-header">
                    <label>Filter Size (F)</label>
                    <span id="val-F" class="value-display">3</span>
                </div>
                <div class="range-wrapper">
                    <button class="btn-adjust" onclick="adjustRange('F', -1)">-</button>
                    <input type="range" id="inp-F" min="1" max="9" value="3">
                    <button class="btn-adjust" onclick="adjustRange('F', 1)">+</button>
                </div>
            </div>

            <!-- Stride S -->
            <div class="control-group">
                <div class="control-header">
                    <label>Stride (S)</label>
                    <span id="val-S" class="value-display">1</span>
                </div>
                <div class="range-wrapper">
                    <button class="btn-adjust" onclick="adjustRange('S', -1)">-</button>
                    <input type="range" id="inp-S" min="1" max="5" value="1">
                    <button class="btn-adjust" onclick="adjustRange('S', 1)">+</button>
                </div>
            </div>

            <!-- Padding P -->
            <div class="control-group">
                <div class="control-header">
                    <label>Padding (P)</label>
                    <span id="val-P" class="value-display">0</span>
                </div>
                <div class="range-wrapper">
                    <button class="btn-adjust" onclick="adjustRange('P', -1)">-</button>
                    <input type="range" id="inp-P" min="0" max="10" value="0">
                    <button class="btn-adjust" onclick="adjustRange('P', 1)">+</button>
                </div>
            </div>

            <!-- Filter Type -->
            <div class="control-group">
                <div class="control-header">
                    <label>Filter Type</label>
                </div>
                <select id="filter-type">
                    <option>Identity</option>
                    <option>Average</option>
                    <option>Upper Border Detection</option>
                    <option>Lower Border Detection</option>
                    <option>Right Border Detection</option>
                    <option>Left Border Detection</option>

                    <option>Horizontal Edge Detection</option>
                    <option>Vertical Edge Detection</option>

                    <option>Diagonal Edge Detection (â†˜)</option>
                    <option>Diagonal Edge Detection (â†—)</option>

                    <option>Sobel X</option>
                    <option>Sobel Y</option>
                    <option>Laplacian</option>
                    <option>Box Blur</option>
                    <option>Gaussian Blur</option>
                    <option>Sharpen</option>
                    <option>Emboss</option>

                    <option>Gabor Horizontal</option>
                    <option>Gabor Vertical</option>
                </select>
            </div>

            <div style="margin-top: 1.2rem; font-size: 0.8rem; color: var(--text-muted); line-height: 1.6;">
                <strong style="color:var(--accent)">Hover Tip:</strong><br>
                Hover over any <strong>output cell</strong> to see:
                <ul style="margin:0.4rem 0 0; padding-left:1.1rem;">
                    <li><span style="color:var(--highlight-calc)">Green</span> â€“ selected output</li>
                    <li><span style="color:var(--highlight-weight)">Yellow</span> â€“ kernel weights used</li>
                    <li><span style="color:var(--highlight-input)">Red</span> â€“ input cells used (white = padding)</li>
                </ul>
            </div>
        </div>
    </aside>

    <!-- Visualization Area -->
    <div class="viz-area">
        <div class="stage-row">
            <!-- Input Image -->
            <div class="panel">
                <div class="panel-title">Input Image (Patch)</div>
                <div class="panel-subtitle" id="input-info"></div>
                <div id="input-grid" class="grid-wrapper"></div>
            </div>

            <div class="symbol">â†’</div>

            <!-- Filter -->
            <div class="panel">
                <div class="panel-title">Filter / Kernel</div>
                <div class="panel-subtitle" id="kernel-info"></div>
                <div id="kernel-grid" class="grid-wrapper"></div>
            </div>

            <div class="symbol">=</div>

            <!-- Output -->
            <div class="panel">
                <div class="panel-title">Output Activation Map</div>
                <div class="panel-subtitle" id="output-info"></div>
                <div id="output-grid" class="grid-wrapper"></div>
            </div>
        </div>

        <div class="status-box" id="status-box">
            Input: <span class="status-highlight" id="status-input-shape"></span> &nbsp; | &nbsp;
            Kernel: <span class="status-highlight" id="status-kernel-shape"></span> &nbsp; | &nbsp;
            Output: <span class="status-highlight" id="status-output-shape"></span>
        </div>
    </div>
</main>

<script>
/*
    JS: convolution logic + hover mapping
*/

const state = {
    imgType: 'simple',
    W: 28,
    F: 3,
    S: 1,
    P: 0,
    filterType: 'Identity'
};

let lastMapping = null; // maps output (oy,ox) â†’ list of {iy,ix,ky,kx}

// ---- DOM elements ----
const els = {
    imgTypeSelect: document.getElementById('img-type'),

    WInput: document.getElementById('inp-W'),
    WVal: document.getElementById('val-W'),

    FInput: document.getElementById('inp-F'),
    FVal: document.getElementById('val-F'),

    SInput: document.getElementById('inp-S'),
    SVal: document.getElementById('val-S'),

    PInput: document.getElementById('inp-P'),
    PVal: document.getElementById('val-P'),

    filterSelect: document.getElementById('filter-type'),

    inputGrid: document.getElementById('input-grid'),
    kernelGrid: document.getElementById('kernel-grid'),
    outputGrid: document.getElementById('output-grid'),

    inputInfo: document.getElementById('input-info'),
    kernelInfo: document.getElementById('kernel-info'),
    outputInfo: document.getElementById('output-info'),

    statusInputShape: document.getElementById('status-input-shape'),
    statusKernelShape: document.getElementById('status-kernel-shape'),
    statusOutputShape: document.getElementById('status-output-shape'),
    statusBox: document.getElementById('status-box')
};

// ------------------------------------------------------------------
//  SIMPLE SMILE IMAGE: fixed 28Ã—28 grayscale matrix (0â€“255, bg=0)
// ------------------------------------------------------------------
const SIMPLE_SMILE_28 = [
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 9, 12, 12, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 98, 156, 228, 249, 249, 237, 170, 100, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 54, 158, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 189, 37, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 101, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 236, 93, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 134, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 131, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 113, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 142, 0, 0, 0, 0],
  [0, 0, 0, 27, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 6, 0, 0, 0],
  [0, 0, 0, 172, 255, 255, 255, 242, 165, 228, 255, 255, 255, 255, 255, 255, 255, 255, 226, 190, 248, 255, 255, 255, 210, 9, 0, 0],
  [0, 0, 44, 237, 255, 255, 255, 62, 0, 34, 218, 255, 255, 255, 255, 255, 255, 223, 37, 0, 72, 255, 255, 255, 255, 60, 0, 0],
  [0, 0, 125, 255, 255, 255, 189, 0, 0, 0, 116, 255, 255, 255, 255, 255, 255, 114, 0, 0, 0, 192, 255, 255, 255, 129, 0, 0],
  [0, 0, 222, 255, 255, 255, 198, 0, 0, 0, 127, 255, 255, 255, 255, 255, 255, 142, 0, 0, 0, 213, 255, 255, 255, 224, 0, 0],
  [0, 0, 226, 255, 255, 255, 255, 117, 31, 133, 251, 255, 255, 255, 255, 255, 255, 254, 126, 50, 151, 255, 255, 255, 255, 234, 4, 0],
  [0, 0, 231, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 237, 10, 0],
  [0, 0, 232, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 238, 9, 0],
  [0, 0, 226, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 234, 0, 0],
  [0, 0, 208, 255, 255, 255, 235, 32, 219, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 64, 204, 255, 255, 255, 209, 0, 0],
  [0, 0, 124, 255, 255, 255, 251, 0, 57, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 99, 0, 232, 255, 255, 255, 114, 0, 0],
  [0, 0, 30, 245, 255, 255, 255, 207, 4, 22, 211, 255, 255, 255, 255, 255, 255, 228, 63, 0, 198, 255, 255, 255, 252, 49, 0, 0],
  [0, 0, 0, 153, 255, 255, 255, 255, 214, 32, 0, 109, 172, 181, 181, 172, 88, 0, 10, 179, 255, 255, 255, 255, 163, 0, 0, 0],
  [0, 0, 0, 6, 255, 255, 255, 255, 255, 255, 164, 13, 0, 0, 0, 0, 2, 152, 242, 255, 255, 255, 255, 255, 1, 0, 0, 0],
  [0, 0, 0, 0, 68, 246, 255, 255, 255, 255, 255, 255, 236, 210, 210, 239, 255, 255, 255, 255, 255, 255, 254, 76, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 76, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 101, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 46, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 250, 66, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 36, 134, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 157, 28, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106, 179, 225, 252, 248, 199, 153, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 30, 28, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
];

/**
 * Return a WÃ—W patch (top-left of 28Ã—28 base face).
 * We ignore imgType since we only have Simple Smile.
 */
function getInputPatch(W, type) {
    W = Math.max(2, Math.min(28, W)); // clamp W
    const base = SIMPLE_SMILE_28;     // 28Ã—28

    const patch = [];
    for (let i = 0; i < W; i++) {
        const row = [];
        for (let j = 0; j < W; j++) {
            row.push(base[i][j]);
        }
        patch.push(row);
    }
    return { patch };
}
    
function valueFmt(v) {
    if (Math.abs(v) < 0.1)
        return Number(v).toPrecision(3);
    else
        return Number(v).toFixed(2);
}
    
// --------------------------------------------------
//  FILTER BUILDERS   (same as your original logic)
// --------------------------------------------------
function embedKernel(base, F) {
    const f0 = base.length;
    if (F <= f0) {
        const k = [];
        for (let i = 0; i < F; i++) {
            const row = [];
            for (let j = 0; j < F; j++) {
                row.push(base[i][j]);
            }
            k.push(row);
        }
        return k;
    }
    const k = Array.from({ length: F }, () => Array(F).fill(0));
    const start = Math.floor(F / 2 - f0 / 2);
    for (let i = 0; i < f0; i++) {
        for (let j = 0; j < f0; j++) {
            k[start + i][start + j] = base[i][j];
        }
    }
    return k;
}

function gaborKernel(F, theta) {
    const k = [];
    const sigma = 0.5;
    const wavelength = 1.0;

    for (let i = 0; i < F; i++) {
        const row = [];
        for (let j = 0; j < F; j++) {
            const x = -1 + (2 * j) / (F - 1);
            const y = -1 + (2 * i) / (F - 1);
            const x_theta = x * Math.cos(theta) + y * Math.sin(theta);
            const y_theta = -x * Math.sin(theta) + y * Math.cos(theta);

            const g = Math.exp(-(x_theta * x_theta + y_theta * y_theta) / (2 * sigma * sigma)) *
                Math.cos((2 * Math.PI * x_theta) / wavelength);
            row.push(g);
        }
        k.push(row);
    }
    return k;
}

function buildFilter(F, filterType) {
    F = parseInt(F, 10);
    const ft = filterType.toLowerCase();
    const zeros = () => Array.from({ length: F }, () => Array(F).fill(0));

    if (ft.includes('identity')) {
        const k = zeros();
        k[Math.floor(F / 2)][Math.floor(F / 2)] = 1.0;
        return k;
    }

    if (ft.includes('average')) {
        const k = zeros();
        const v = 1.0 / (F * F);
    
        for (let i = 0; i < F; i++) {
            for (let j = 0; j < F; j++) {
                k[i][j] = v;
            }
        }
        return k;
    }
    
    if (filterType === 'Upper Border Detection') {
        const k = zeros();
        for (let j = 0; j < F; j++) {
            k[0][j] = -1.0;
            k[F - 1][j] = 1.0;
        }
        return k;
    }
    if (filterType === 'Lower Border Detection') {
        const k = zeros();
        for (let j = 0; j < F; j++) {
            k[0][j] = 1.0;
            k[F - 1][j] = -1.0;
        }
        return k;
    }
    if (filterType === 'Right Border Detection') {
        const k = zeros();
        for (let i = 0; i < F; i++) {
            k[i][0] = -1.0;
            k[i][F - 1] = 1.0;
        }
        return k;
    }
    if (filterType === 'Left Border Detection') {
        const k = zeros();
        for (let i = 0; i < F; i++) {
            k[i][0] = 1.0;
            k[i][F - 1] = -1.0;
        }
        return k;
    }

    if (filterType === 'Horizontal Edge Detection') {
        const k = zeros();
        for (let i = 0; i < F; i++) {
            for (let j = 0; j < F; j++) {
                k[i][j] = (i < Math.floor(F / 2)) ? -1.0 : 1.0;
            }
        }
        return k;
    }
    if (filterType === 'Vertical Edge Detection') {
        const k = zeros();
        for (let i = 0; i < F; i++) {
            for (let j = 0; j < F; j++) {
                k[i][j] = (j < Math.floor(F / 2)) ? -1.0 : 1.0;
            }
        }
        return k;
    }

    if (filterType === 'Diagonal Edge Detection (â†˜)') {
        const k = zeros();
        for (let i = 0; i < F; i++) {
            k[i][i] = 1.0;
        }
        for (let i = 0; i < F - 1; i++) {
            k[i][i + 1] = -1.0;
        }
        return k;
    }
    if (filterType === 'Diagonal Edge Detection (â†—)') {
        const k = zeros();
        for (let i = 0; i < F; i++) {
            k[i][F - 1 - i] = 1.0;
        }
        for (let i = 0; i < F - 1; i++) {
            k[i + 1][F - 1 - i] = -1.0;
        }
        return k;
    }

    if (ft.includes('sobel x')) {
        const base = [
            [-1, 0, 1],
            [-2, 0, 2],
            [-1, 0, 1]
        ];
        return embedKernel(base, F);
    }
    if (ft.includes('sobel y')) {
        const base = [
            [-1, -2, -1],
            [0, 0, 0],
            [1, 2, 1]
        ];
        return embedKernel(base, F);
    }

    if (ft.includes('laplacian')) {
        const base = [
            [0, -1, 0],
            [-1, 4, -1],
            [0, -1, 0]
        ];
        return embedKernel(base, F);
    }

    if (ft.includes('box blur')) {
        const k = zeros();
        const val = 1.0 / (F * F);
        for (let i = 0; i < F; i++) {
            for (let j = 0; j < F; j++) {
                k[i][j] = val;
            }
        }
        return k;
    }

    if (ft.includes('gaussian blur')) {
        const k = zeros();
        const sigma = 0.6;
        let sum = 0;
        for (let i = 0; i < F; i++) {
            for (let j = 0; j < F; j++) {
                const x = -1 + (2 * j) / (F - 1);
                const y = -1 + (2 * i) / (F - 1);
                const val = Math.exp(-(x * x + y * y) / (2 * sigma * sigma));
                k[i][j] = val;
                sum += val;
            }
        }
        for (let i = 0; i < F; i++) {
            for (let j = 0; j < F; j++) {
                k[i][j] /= sum;
            }
        }
        return k;
    }

    if (ft.includes('sharpen')) {
        const base = [
            [0, -1, 0],
            [-1, 5, -1],
            [0, -1, 0]
        ];
        return embedKernel(base, F);
    }

    if (ft.includes('emboss')) {
        const base = [
            [-2, -1, 0],
            [-1, 1, 1],
            [0, 1, 2]
        ];
        return embedKernel(base, F);
    }

    if (ft.includes('gabor') && ft.includes('horizontal')) {
        return gaborKernel(F, 0.0);
    }
    if (ft.includes('gabor') && ft.includes('vertical')) {
        return gaborKernel(F, Math.PI / 2);
    }

    return zeros();
}

// --------------------------------------------------
//  CONVOLUTION + MAPPING
// --------------------------------------------------
function conv2d(image, kernel, stride, padding) {
    stride = parseInt(stride, 10);
    padding = parseInt(padding, 10);

    const H = image.length;
    const W = image[0].length;
    const F = kernel.length;

    const H_p = H + 2 * padding;
    const W_p = W + 2 * padding;
    const padded = Array.from({ length: H_p }, () => Array(W_p).fill(0));

    for (let i = 0; i < H; i++) {
        for (let j = 0; j < W; j++) {
            padded[i + padding][j + padding] = image[i][j];
        }
    }

    const out_h = Math.floor((H_p - F) / stride) + 1;
    const out_w = Math.floor((W_p - F) / stride) + 1;

    if (out_h <= 0 || out_w <= 0) {
        return { out: [[0]], outNorm: [[0]], ok: false, mapping: null };
    }

    const out = Array.from({ length: out_h }, () => Array(out_w).fill(0));
    const mapping = Array.from({ length: out_h }, () =>
        Array.from({ length: out_w }, () => null)
    );

    for (let i = 0; i < out_h; i++) {
        for (let j = 0; j < out_w; j++) {
            let sum = 0;
            const h_start = i * stride;
            const w_start = j * stride;
            const contribs = [];

            for (let ki = 0; ki < F; ki++) {
                for (let kj = 0; kj < F; kj++) {
                    const iy = h_start + ki;
                    const ix = w_start + kj;
                    const val = padded[iy][ix] * kernel[ki][kj];
                    sum += val;
                    contribs.push({ iy, ix, ky: ki, kx: kj });
                }
            }
            out[i][j] = sum;
            mapping[i][j] = contribs;
        }
    }

    let vmin = Infinity;
    let vmax = -Infinity;
    for (let i = 0; i < out_h; i++) {
        for (let j = 0; j < out_w; j++) {
            vmin = Math.min(vmin, out[i][j]);
            vmax = Math.max(vmax, out[i][j]);
        }
    }

    let outNorm;
    if (vmax !== vmin) {
        outNorm = out.map(row => row.map(v => (v - vmin) / (vmax - vmin)));
    } else {
        outNorm = out.map(row => row.map(() => 0));
    }

    return { out, outNorm, ok: true, mapping };
}

// --------------------------------------------------
//  GRID DRAWING WITH HOVER HIGHLIGHTS
// --------------------------------------------------
function drawMatrix(container, M, options = {}) {
    const {
        showValues = false,
        mode = 'image',    // 'image' | 'kernel' | 'output'
        type = null,       // 'input' | 'kernel' | 'output'
        paddingInfo = null // { W, P } for input grid
    } = options;

    const rows = M.length;
    const cols = M[0].length;

    container.innerHTML = '';
    container.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;

    let min = Infinity, max = -Infinity;
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            min = Math.min(min, M[i][j]);
            max = Math.max(max, M[i][j]);
        }
    }

    const range = max - min || 1;
    const center = (min + max) / 2 || 0;

    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            const v = M[i][j];
            const cell = document.createElement('div');
            cell.className = 'cell';

            // ----- base coloring -----
            if (mode === 'image' || mode === 'output') {
                const norm = (v - min) / range;
                const light = 20 + norm * 60;
                if (mode === 'image') {
                    cell.style.backgroundColor = `hsl(215, 25%, ${light}%)`;
                } else {
                    const alpha = 0.2 + norm * 0.8;
                    cell.style.backgroundColor = `rgba(163, 230, 53, ${alpha})`;
                }
            } else if (mode === 'kernel') {
                const norm = (v - center) / (Math.abs(max - center) + 1e-6);
                const sign = norm >= 0 ? 1 : -1;
                const mag = Math.min(1, Math.abs(norm));
                const sat = 50 + mag * 30;
                const light = 50 - mag * 15;
                const hue = (sign > 0) ? 0 : 220;
                cell.style.backgroundColor = `hsl(${hue}, ${sat}%, ${light}%)`;
            }

            if (showValues) {
                cell.textContent = valueFmt(v);
            }

            // ----- attach coordinates & classes -----
            if (type === 'input') {
                cell.dataset.iy = i;
                cell.dataset.ix = j;
                cell.classList.add('input-cell');

                if (paddingInfo) {
                    const { W, P } = paddingInfo;
                    const isPadding =
                        i < P || i >= P + W || j < P || j >= P + W;

                    if (isPadding) {
                        cell.classList.add('padding');
                        cell.textContent = '0';
                        cell.style.backgroundColor = '#ffffff';
                        cell.style.color = '#000000';
                    }
                }
            } else if (type === 'kernel') {
                cell.dataset.ky = i;
                cell.dataset.kx = j;
                cell.classList.add('kernel-cell');
            } else if (type === 'output') {
                cell.dataset.oy = i;
                cell.dataset.ox = j;
                cell.classList.add('output-cell');
                cell.addEventListener('mouseenter', () => highlightForOutput(i, j));
                cell.addEventListener('mouseleave', clearHighlights);
            }

            container.appendChild(cell);
        }
    }
}

// ---- Hover highlight logic ----
function highlightForOutput(oy, ox) {
    if (!lastMapping || !lastMapping[oy] || !lastMapping[oy][ox]) return;

    clearHighlights();

    const contribs = lastMapping[oy][ox];

    const outCell = document.querySelector(
        `.output-cell[data-oy="${oy}"][data-ox="${ox}"]`
    );
    if (outCell) outCell.classList.add('active-result');

    contribs.forEach(c => {
        const inCell = document.querySelector(
            `.input-cell[data-iy="${c.iy}"][data-ix="${c.ix}"]`
        );
        if (inCell) inCell.classList.add('active-input');

        const kCell = document.querySelector(
            `.kernel-cell[data-ky="${c.ky}"][data-kx="${c.kx}"]`
        );
        if (kCell) kCell.classList.add('active-weight');
    });
}

function clearHighlights() {
    document.querySelectorAll('.active-input').forEach(el => el.classList.remove('active-input'));
    document.querySelectorAll('.active-weight').forEach(el => el.classList.remove('active-weight'));
    document.querySelectorAll('.active-result').forEach(el => el.classList.remove('active-result'));
}

// --------------------------------------------------
//  STATE HELPERS & MAIN RENDER
// --------------------------------------------------
function clampState() {
    state.W = Math.max(2, Math.min(28, state.W));
    state.F = Math.max(1, Math.min(9, state.F));
    state.S = Math.max(1, Math.min(5, state.S));
    state.P = Math.max(0, Math.min(10, state.P));
}

function updateUIFromState() {
    els.WInput.value = state.W;
    els.WVal.textContent = state.W;

    els.FInput.value = state.F;
    els.FVal.textContent = state.F;

    els.SInput.value = state.S;
    els.SVal.textContent = state.S;

    els.PInput.value = state.P;
    els.PVal.textContent = state.P;

    els.filterSelect.value = state.filterType;
    els.imgTypeSelect.value = state.imgType;
}

function adjustRange(key, delta) {
    state[key] += delta;
    clampState();
    updateUIFromState();
    render();
}

function render() {
    clampState();
    clearHighlights();

    const { imgType, W, F, S, P, filterType } = state;

    const { patch } = getInputPatch(W, imgType);

    const displayH = W + 2 * P;
    const displayW = W + 2 * P;
    const displayImg = Array.from({ length: displayH }, () => Array(displayW).fill(0));

    for (let i = 0; i < W; i++) {
        for (let j = 0; j < W; j++) {
            displayImg[i + P][j + P] = patch[i][j];
        }
    }

    const kernel = buildFilter(F, filterType);
    const { out, outNorm, ok, mapping } = conv2d(patch, kernel, S, P);
    lastMapping = mapping;

    drawMatrix(els.inputGrid, displayImg, {
        showValues: false,
        mode: 'image',
        type: 'input',
        paddingInfo: { W, P }
    });

    drawMatrix(els.kernelGrid, kernel, {
        showValues: true,
        mode: 'kernel',
        type: 'kernel'
    });

    if (ok) {
        drawMatrix(els.outputGrid, outNorm, {
            showValues: false,
            mode: 'output',
            type: 'output'
        });
    } else {
        els.outputGrid.innerHTML =
            '<div style="padding:10px; font-size:0.8rem; color:#f43f5e;">Invalid sizes (no output)</div>';
        els.outputGrid.style.gridTemplateColumns = '1fr';
        lastMapping = null;
    }

    const patternName = 'Simple Smile';

    els.inputInfo.textContent = `Pattern="${patternName}" | Size=${displayImg.length}Ã—${displayImg[0].length} (with P=${P})`;
    els.kernelInfo.textContent = `Type=${filterType}, Size=${F}Ã—${F}`;
    els.outputInfo.textContent = ok ? `Size=${out.length}Ã—${out[0].length}, Stride=${S}` : 'No valid output';

    els.statusInputShape.textContent = `${displayImg.length}Ã—${displayImg[0].length}`;
    els.statusKernelShape.textContent = `${F}Ã—${F}`;
    els.statusOutputShape.textContent = ok ? `${out.length}Ã—${out[0].length}` : 'â€”';
    els.statusBox.style.borderColor = ok ? 'var(--border-color)' : '#f97373';
}

// --------------------------------------------------
//  EVENT LISTENERS & INIT
// --------------------------------------------------
els.WInput.addEventListener('input', e => {
    state.W = parseInt(e.target.value, 10);
    clampState();
    updateUIFromState();
    render();
});
els.FInput.addEventListener('input', e => {
    state.F = parseInt(e.target.value, 10);
    clampState();
    updateUIFromState();
    render();
});
els.SInput.addEventListener('input', e => {
    state.S = parseInt(e.target.value, 10);
    clampState();
    updateUIFromState();
    render();
});
els.PInput.addEventListener('input', e => {
    state.P = parseInt(e.target.value, 10);
    clampState();
    updateUIFromState();
    render();
});
els.filterSelect.addEventListener('change', e => {
    state.filterType = e.target.value;
    render();
});
els.imgTypeSelect.addEventListener('change', e => {
    state.imgType = e.target.value;
    render();
});

// Init immediately (no sprite to wait for)
updateUIFromState();
render();
</script>

</body>
</html>
